`timescale 1ns / 1ps

module fpu_tb;

    // Testbench signals
    reg clk;
    reg [31:0] a, b;
    reg [31:0] mem_data_in;
    reg [3:0] opcode;
    reg load;
    reg store;
    reg [31:0] address;
    reg [4:0] rd;
    reg write_enable;
    wire [31:0] result;
    wire [31:0] mem_data_out;

    // Instantiate the FPU
    fpu uut (
        .clk(clk),
        .a(a),
        .b(b),
        .mem_data_in(mem_data_in),
        .opcode(opcode),
        .load(load),
        .store(store),
        .address(address),
        .rd(rd),
        .write_enable(write_enable),
        .result(result),
        .mem_data_out(mem_data_out)
    );

    // Clock generation
    initial begin
        clk = 0;
        forever #5 clk = ~clk; // 100MHz clock
    end

    // Test values in IEEE-754 32-bit format
    // 2.759     = 0x40307AE1
    // -3.875    = 0xC0780000  
    // 0.000663  = 0x3A2E147B
    // 10.2283   = 0x4123A3D7
    parameter FLOAT_2_759   = 32'h40307AE1;
    parameter FLOAT_NEG3_875= 32'hC0780000;
    parameter FLOAT_0_000663= 32'h3A2E147B;
    parameter FLOAT_10_2283 = 32'h4123A3D7;

    // Function to convert float to hex string for display
    function [87:0] float_to_string;
        input [31:0] fp_val;
        begin
            case(fp_val)
                FLOAT_2_759:    float_to_string = "2.759    ";
                FLOAT_NEG3_875: float_to_string = "-3.875   ";
                FLOAT_0_000663: float_to_string = "0.000663 ";
                FLOAT_10_2283:  float_to_string = "10.2283  ";
                default:        float_to_string = "Unknown  ";
            endcase
        end
    endfunction

    // Test procedure
    initial begin
        // Initialize signals
        a = 0;
        b = 0;
        mem_data_in = 0;
        opcode = 0;
        load = 0;
        store = 0;
        address = 0;
        rd = 0;
        write_enable = 0;

        $display("=== FPU Testbench Started ===");
        $display("Test Values:");
        $display("  2.759    = 0x%08h", FLOAT_2_759);
        $display("  -3.875   = 0x%08h", FLOAT_NEG3_875);
        $display("  0.000663 = 0x%08h", FLOAT_0_000663);
        $display("  10.2283  = 0x%08h", FLOAT_10_2283);
        $display("");

        // Wait for initial setup
        #20;

        // Test 1: Addition Operations
        $display("=== ADDITION TESTS ===");
        test_operation(FLOAT_2_759, FLOAT_NEG3_875, 4'b0000, "ADD", "2.759 + (-3.875)");
        test_operation(FLOAT_0_000663, FLOAT_10_2283, 4'b0000, "ADD", "0.000663 + 10.2283");
        test_operation(FLOAT_2_759, FLOAT_0_000663, 4'b0000, "ADD", "2.759 + 0.000663");
        test_operation(FLOAT_NEG3_875, FLOAT_10_2283, 4'b0000, "ADD", "-3.875 + 10.2283");

        // Test 2: Subtraction Operations
        $display("\n=== SUBTRACTION TESTS ===");
        test_operation(FLOAT_2_759, FLOAT_NEG3_875, 4'b0001, "SUB", "2.759 - (-3.875)");
        test_operation(FLOAT_10_2283, FLOAT_0_000663, 4'b0001, "SUB", "10.2283 - 0.000663");
        test_operation(FLOAT_0_000663, FLOAT_2_759, 4'b0001, "SUB", "0.000663 - 2.759");
        test_operation(FLOAT_NEG3_875, FLOAT_10_2283, 4'b0001, "SUB", "-3.875 - 10.2283");

        // Test 3: Multiplication Operations
        $display("\n=== MULTIPLICATION TESTS ===");
        test_operation(FLOAT_2_759, FLOAT_NEG3_875, 4'b0010, "MUL", "2.759 * (-3.875)");
        test_operation(FLOAT_0_000663, FLOAT_10_2283, 4'b0010, "MUL", "0.000663 * 10.2283");
        test_operation(FLOAT_2_759, FLOAT_0_000663, 4'b0010, "MUL", "2.759 * 0.000663");
        test_operation(FLOAT_NEG3_875, FLOAT_10_2283, 4'b0010, "MUL", "-3.875 * 10.2283");

        // Test 4: Division Operations
        $display("\n=== DIVISION TESTS ===");
        test_operation(FLOAT_2_759, FLOAT_NEG3_875, 4'b0011, "DIV", "2.759 / (-3.875)");
        test_operation(FLOAT_10_2283, FLOAT_0_000663, 4'b0011, "DIV", "10.2283 / 0.000663");
        test_operation(FLOAT_0_000663, FLOAT_2_759, 4'b0011, "DIV", "0.000663 / 2.759");
        test_operation(FLOAT_NEG3_875, FLOAT_10_2283, 4'b0011, "DIV", "-3.875 / 10.2283");

        // Test 5: MIN/MAX Operations
        $display("\n=== MIN/MAX TESTS ===");
        test_operation(FLOAT_2_759, FLOAT_NEG3_875, 4'b0100, "MIN", "MIN(2.759, -3.875)");
        test_operation(FLOAT_0_000663, FLOAT_10_2283, 4'b0100, "MIN", "MIN(0.000663, 10.2283)");
        test_operation(FLOAT_2_759, FLOAT_NEG3_875, 4'b0101, "MAX", "MAX(2.759, -3.875)");
        test_operation(FLOAT_0_000663, FLOAT_10_2283, 4'b0101, "MAX", "MAX(0.000663, 10.2283)");

        // Test 6: Square Root Operations
        $display("\n=== SQUARE ROOT TESTS ===");
        test_sqrt_operation(FLOAT_2_759, "SQRT(2.759)");
        test_sqrt_operation(FLOAT_0_000663, "SQRT(0.000663)");
        test_sqrt_operation(FLOAT_10_2283, "SQRT(10.2283)");
        // Note: Cannot test sqrt of negative number as it should return NaN

        // Test 7: Comparison Operations
        $display("\n=== COMPARISON TESTS ===");
        test_operation(FLOAT_2_759, FLOAT_NEG3_875, 4'b1000, "FEQ", "2.759 == -3.875");
        test_operation(FLOAT_2_759, FLOAT_2_759, 4'b1000, "FEQ", "2.759 == 2.759");
        test_operation(FLOAT_0_000663, FLOAT_10_2283, 4'b1001, "FLT", "0.000663 < 10.2283");
        test_operation(FLOAT_NEG3_875, FLOAT_2_759, 4'b1001, "FLT", "-3.875 < 2.759");
        test_operation(FLOAT_2_759, FLOAT_10_2283, 4'b1010, "FLE", "2.759 <= 10.2283");
        test_operation(FLOAT_10_2283, FLOAT_10_2283, 4'b1010, "FLE", "10.2283 <= 10.2283");

        // Test 8: Conversion Operations
        $display("\n=== CONVERSION TESTS ===");
        test_conversion(FLOAT_2_759, 4'b1100, "FCVT.W.S", "2.759 to signed int");
        test_conversion(FLOAT_NEG3_875, 4'b1100, "FCVT.W.S", "-3.875 to signed int");
        test_conversion(FLOAT_10_2283, 4'b1101, "FCVT.WU.S", "10.2283 to unsigned int");
        test_conversion(32'd3, 4'b1110, "FCVT.S.W", "3 (signed) to float");
        test_conversion(32'd10, 4'b1111, "FCVT.S.WU", "10 (unsigned) to float");

        // Test 9: Load/Store Operations
        $display("\n=== LOAD/STORE TESTS ===");
        test_load_store();

        // Test 10: Register Write Test
        $display("\n=== REGISTER WRITE TESTS ===");
        test_register_write();

        $display("\n=== All Tests Completed ===");
        $finish;
    end

    // Task to test arithmetic/logic operations
    task test_operation;
        input [31:0] val_a, val_b;
        input [3:0] op;
        input [47:0] op_name;
        input [159:0] description;
        begin
            a = val_a;
            b = val_b;
            opcode = op;
            load = 0;
            store = 0;
            #10;
            $display("%s: %s = 0x%08h", op_name, description, result);
        end
    endtask

    // Task to test square root operations (single operand)
    task test_sqrt_operation;
        input [31:0] val_a;
        input [127:0] description;
        begin
            a = val_a;
            b = 32'h0;
            opcode = 4'b0110;
            load = 0;
            store = 0;
            #10;
            $display("SQRT: %s = 0x%08h", description, result);
        end
    endtask

    // Task to test conversion operations
    task test_conversion;
        input [31:0] val_a;
        input [3:0] op;
        input [63:0] op_name;
        input [191:0] description;
        begin
            a = val_a;
            b = 32'h0;
            opcode = op;
            load = 0;
            store = 0;
            #10;
            $display("%s: %s = 0x%08h (%d)", op_name, description, result, $signed(result));
        end
    endtask

    // Task to test load/store operations
    task test_load_store;
        begin
            // Test Load Operation
            $display("Testing LOAD operation:");
            mem_data_in = FLOAT_2_759;
            address = 32'h1000; // Aligned address
            load = 1;
            store = 0;
            #10;
            $display("  LOAD from aligned address: result = 0x%08h", result);
            
            // Test misaligned load
            address = 32'h1001; // Misaligned address
            #10;
            $display("  LOAD from misaligned address: result = 0x%08h (should set fcsr[3])", result);
            
            load = 0;
            
            // Test Store Operation
            $display("Testing STORE operation:");
            a = FLOAT_NEG3_875;
            address = 32'h2000; // Aligned address
            store = 1;
            #10;
            $display("  STORE to aligned address: mem_data_out = 0x%08h", mem_data_out);
            
            // Test misaligned store
            address = 32'h2001; // Misaligned address
            #10;
            $display("  STORE to misaligned address: mem_data_out = 0x%08h (should set fcsr[3])", mem_data_out);
            
            store = 0;
        end
    endtask

    // Task to test register write functionality
    task test_register_write;
        begin
            $display("Testing register write functionality:");
            
            // Test writing to register f5
            a = FLOAT_2_759;
            b = FLOAT_0_000663;
            opcode = 4'b0000; // ADD operation
            rd = 5'd5; // Register f5
            write_enable = 1;
            #10; // Wait for combinational logic
            @(posedge clk); // Wait for register write
            #1;
            $display("  Written result 0x%08h to register f5", result);
            
            // Test writing to register f10
            a = FLOAT_10_2283;
            b = FLOAT_NEG3_875;
            opcode = 4'b0010; // MUL operation
            rd = 5'd10; // Register f10
            #10; // Wait for combinational logic
            @(posedge clk); // Wait for register write
            #1;
            $display("  Written result 0x%08h to register f10", result);
            
            write_enable = 0;
        end
    endtask

    // Monitor to display key signal changes
    initial begin
        $monitor("Time=%0t: a=0x%08h, b=0x%08h, opcode=%b, result=0x%08h", 
                 $time, a, b, opcode, result);
    end

    // Dump waveforms for debugging
    initial begin
        $dumpfile("fpu_tb.vcd");
        $dumpvars(0, fpu_tb);
    end

endmodule